fromsympy import*
x , y = symbols('x y')
u=exp(x)*(x*cos(y)-y*sin(y)) # input multivariable function u=u(x,y)
print('u(x,y)=',u)
dux = diff (u , x ) # Differentiate u w.r.t x
duy = diff (u , y ) # Differentiate u w.r.t. y
duxy = diff ( dux , y ) # computing uxy
duyx = diff ( duy , x ) # computing uyx
print('uxy=',duxy)
print('uyx=',duyx)
# Check the condtionuxy=uyx
ifduxy == duyx :
print('Mixed partial derivatives are equal')
else :
print('Mixed partial derivatives are not equal')





import sympy
from sympy import Symbol , solve , Derivative , pprint
x= Symbol('x')
y= Symbol('y')
f=x**3+y**3-3*x-12*y+20
d1= Derivative (f , x ).doit ()
d2= Derivative (f , y ).doit ()
criticalpoints1 = solve( d1)
criticalpoints2 = solve( d2 )
print(' Solution set for x=',criticalpoints1,
'\n Solution set for y=', criticalpoints2)
s1= Derivative(f ,x , 2 ).doit()
s2= Derivative(f ,y , 2 ).doit()
s3= Derivative( Derivative(f , y ) ,x ) .doit()
q1=s1.subs({x: criticalpoints1[0], y: criticalpoints2[0]}).evalf ()
q2=s2.subs({x: criticalpoints1[0], y: criticalpoints2[0]}).evalf ()
q3=s3.subs({x: criticalpoints1[0], y: criticalpoints2[0]}).evalf ()
delta =q1*q2-q3 ** 2
if( delta >0 and q1<0 ):
print("f takes Maximum value at",'(',criticalpoints1[0] ,',',
criticalpoints2[0],')')
elif( delta >0 and q1>0 ):
print(" f takes Minimum value at",'(',criticalpoints1[0] ,',',
criticalpoints2[0],')')
if( delta <0 ):
print ("The point is a saddle point at",'(',criticalpoints1[0],
',',criticalpoints2[0],')' )
if( delta ==0 ):
print(" Further tests required at",'(',criticalpoints1[0] ,',',
criticalpoints2[0],')' )
f1=f.subs ({x: criticalpoints1[0],y: criticalpoints2[0]}).evalf()
print('Functional value is f(x,y)=',f1)
# ---- OPTIONAL PART : GRAPHING THE GIVEN FUNCTION(3D) ----
# Import libraries
from mpl_toolkits import mplot3d
import numpy as np
import matplotlib.pyplot as plt

# Creating dataset
x = np.outer(np.linspace(-3, 3, 2000), np.ones(2000))
y = x.copy().T # transpose
z = x**3+y**3-3*x-12*y+20
# Creating figure
fig = plt.figure(figsize =(15, 15))
ax = plt.axes(projection ='3d')
# Creating plot
ax.plot_surface(x, y, z)
# show plot
plt.show()
